
#' Buffer-Crop-Function
#'
#' @param pts List of Points (Sites)
#' @param dem DEM
#' @param extent extent of buffer that will be croped in KM
#' @return dem croped DEM
#' @export

BufferCrop <- function(pts, dem, extent) {

  points <- convertDFtoSPDF(pts)

  buffer <- gBuffer(points, width = (extent*1000))
  dem <- mask(dem, buffer)
  return(dem)
}


#' Transformierung eines Layers in die gewünschte Projektion
#'
#'@keywords internal

trans <- function(layer, EPSG) {
  layer <- spTransform(layer, CRS( paste("+init=epsg:", EPSG, "")))
  return(layer)
}


#' Verteilungen berechnen

stat <- function(rst, pts) {
  extr <- round(extract(rst, pts)) # extrahiert Werte
  obs <- data.frame(table(extr)) # Auszähltabelle
  colnames(obs) <- c("Var1", "Freq")

  exp <- data.frame(table(round(getValues(rst))))

  merge = merge(x = exp,
                y = obs,
                by = 'Var1',
                all = TRUE)
  merge$ExpPct <- merge$Freq.x / sum(merge$Freq.x)

  sites <- sum(merge$Freq.y, na.rm = TRUE) # count of sites

  # Expected Count of sites (PAL_MESO_site = 49) per class
  merge$ExpSites <- sites * merge$ExpPct

  merge <- replace(merge, is.na(merge), 0) # leerstellen zu 0

  return(merge)
}


#' Chi2-Test for Goodness of fit

chi <- function(merge) {
  chisq <- chisq.test(merge$Freq.y,
                      p = merge$ExpSites,
                      rescale.p=TRUE)

  if (chisq$p.value < 0.05) {
    print("Good")
  } else {
    print("Not Good")
  }
}
